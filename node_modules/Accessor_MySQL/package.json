{
  "author": {
    "name": "Buwei Chiu",
    "email": "bu@hax4.in",
    "url": "https://github.com/bu/"
  },
  "name": "Accessor_MySQL",
  "description": "A MySQL database wrapper, provide easy access to database without writing SQL code",
  "version": "0.4.1",
  "homepage": "https://github.com/bu/Accessor_MySQL",
  "repository": {
    "type": "git",
    "url": "git://github.com/bu/Accessor_MySQL.git"
  },
  "dependencies": {
    "Accessor": ">=0.2.0",
    "mysql": ">=0.9.6",
    "generic-pool": ">=1.0.11"
  },
  "devDependencies": {},
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "main": "index.js",
  "keywords": [
    "mysql",
    "accessor",
    "genericobject",
    "observer"
  ],
  "license": "MIT",
  "readme": "# Accessor_MySQL 0.4.1\n\nA MySQL database wrapper, provide easy access to database without writing SQL code\n\n\n## Install & Setup\n\n1. Install through npm, following command will do that:\n\n\t\tnpm install Accessor_MySQL\n\t\t\n2. Create a config directory under your application, and create a database.js under that, which may contain like:\n\n\t\tvar databaseConfig = { \n    \t\tuser: \"YOUR_DATABASE_USER\",\n\t\t    password: \"YOUR_DATABASE_PASSWORD\",\n\t    \tdatabase: \"TARGET_DATABASE\",\n\t    \thost: \"localhost\",\n    \t\tport: 3306\n\t\t};\n\n\t\tmodule.exports = databaseConfig;\n\n3. Now, Accessor_MySQL is ready to use.\n\n\n## Usage\n\n1. Require the Accessor module in your script\n\n\t\tvar Accessor = require(\"Accessor\");\n\n2. Place constructor where you need the Accessor. Do not forget to specify your database engine.\n\n\t\tvar tester = Accessor(\"YOUR_TARGET_TABLE\", \"MySQL\");\n\n3. After initialization, Accessor will try to obtain the schema, and store it to verify  column existence while updating or creating.\n\n### Methods\n\n#### accessor.select( {options}, callback(err, data, fields) );\n\nPerform a select query to obtain data, for example:\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\tvar options = {\n\t\t\twhere: [\n\t\t\t\t[\"id\", \">\", 10],\n\t\t\t\t\"AND\",\n\t\t\t\t[\"email\",\"LIKE\",\"%@gmail.com\"]\n\t\t\t],\n\t\t\t\n\t\t\tlimit: 100,\n\t\t\toffset: 50,\n\t\t\t\n\t\t\tfields: [\"name\"]\n\t\t};\n\t\t\n\t\ttester.select( options, function(err, data, fields) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn data;\n\t\t} );\n\nCurrently, {options} has implements following attributes:\n \n * where\n * limit\n * offset\n * fields \t\t\n \n##### Note\n \nOptions may omit which retrieve all records, i.e.\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\ttester.select( function(err, data, fields) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn data;\n\t\t} );\n\n#### accessor.create( {dataObject}, callback(err, info) );\n\nInsert data record by given dataObject\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\tvar dataObject = {\n\t\t\tname: \"bu\",\n\t\t\temail: \"bu@hax4.in\",\n\t\t\tnonSchemaColumn: \"test\"\n\t\t};\n\t\t\n\t\ttester.create( dataObject, function(err, info) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn info.insertId;\n\t\t} );\n\n##### Note\n\n* On above example, we give a non-exist column called \"nonSchemaColumn\" to Accessor, which may cause hangup if we insert that to sql query.\n\n\tIndeed, Accessor will try to check each attribute and ignore them if not exists, and that should print *(on console)*\n\t\n\t\tWarning: nonSchemaColumn is not in database schema, and is not inserted into queryset\n\n\n#### accessor.update( {options}, {updated_dataObject}, callback(err, info) );\n\nUpdate records filter by option.where with updated_dataObject\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\tvar dataObject = {\n\t\t\temail: \"bu@hax4.in\",\n\t\t\tnonSchemaColumn: \"test\"\n\t\t};\n\t\t\n\t\tvar options = {\n\t\t\twhere: [ \n\t\t\t\t[\"name\", \"=\", \"bu\"] \n\t\t\t],\n\t\t};\n\t\t\n\t\ttester.update( options, dataObject, function(err, info) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn info.affectedRows;\n\t\t} );\n\t\t\n##### Note\n\n* On above example, we give a non-exist column called \"nonSchemaColumn\" to Accessor, which may cause hangup if we update that in sql query.\n\n\tIndeed, Accessor will try to check each attribute and ignore them if not exists, and that should print *(on console)*\n\t\n\t\tWarning: nonSchemaColumn is not in database schema, and is not inserted into queryset\n\n* If options is omitted, it will update all records. (due to no filter)\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\tvar dataObject = {\n\t\t\temail: \"bu@hax4.in\",\n\t\t\tnonSchemaColumn: \"test\"\n\t\t};\n\t\n\t\ttester.update( {}, dataObject, function(err, info) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn info.affectedRows;\n\t\t} );\n\n\n#### accessor.remove( {options}, callback(err, info) );\n\nRemove records filter by options.where\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\t\n\t\tvar options = {\n\t\t\twhere: [ \n\t\t\t\t[\"name\", \"=\", \"bu\"] \n\t\t\t],\n\t\t};\n\t\t\n\t\ttester.update( options, function(err, info) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn info.affectedRows;\n\t\t} );\n\t\t\n##### Note\n\n* If options is omitted, it will remove all records. (due to no filter)\n\n\t\t// test_table schema: id, name, email\n\n\t\tvar tester = Accessor(\"test_table\");\n\t\n\t\ttester.remove( {}, function(err, info) {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\t\n\t\t\t\n\t\t\treturn info.affectedRows;\n\t\t} );\n\n### Observer\n\nYou can register to some methods, that will notify when such things occured. (e.g. UPDATE)\n\n\n\t\t// following example will register a function that print out trigger event name\n\t\t\n\t\tvar Accessor = require(\"Accesor\");\n\t\t\n\t\tvar Log = Accessor(\"Log\", \"MySQL\");\n\t\t\n\t\t// methods can be register are SELECT, CREATE, UPDATE, REMOVE, INIT\n\t\tvar register_methods = [\"SELECT\", \"DELETE\", \"CREATE\", \"INIT\", \"UPDATE\"];\n\t\t\n\t\tLog.registerObserver(register_methods, function(event){\n\t\t\tconsole.log(event);\n\t\t});\n\t\t\n\n### LICENSE\n\nCopyright (c) 2012 Buwei Chiu <bu@hax4.in>\n\nLicensed under the MIT License\n",
  "readmeFilename": "README.md",
  "_id": "Accessor_MySQL@0.4.1",
  "dist": {
    "shasum": "cd4c43fae920a6400017796cf7c209ad4090cac8",
    "tarball": "http://registry.npmjs.org/Accessor_MySQL/-/Accessor_MySQL-0.4.1.tgz"
  },
  "_npmVersion": "1.1.65",
  "_npmUser": {
    "name": "bu",
    "email": "bu@hax4.in"
  },
  "maintainers": [
    {
      "name": "bu",
      "email": "bu@hax4.in"
    }
  ],
  "directories": {},
  "_shasum": "cd4c43fae920a6400017796cf7c209ad4090cac8",
  "_resolved": "https://registry.npmjs.org/Accessor_MySQL/-/Accessor_MySQL-0.4.1.tgz",
  "_from": "Accessor_MySQL@*"
}
